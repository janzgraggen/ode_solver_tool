/**
https://codeskeleton-nyvvxr7lzakw9hvk3r5xya.streamlit.app/
*/

class f
    private bool IsLinear const
    private (*f)(double y, double t)

class SysEqnSolver
    private SolverAlgo* solverMethod;
    public virtual eigen::vector SysSolve()
    public void SetSolverMethod(SolverAlgo* method)
    public SolverAlgo* GetSolverMethod()

    class LinSysEqnSolver(SysEqnSolver)
        private eigen::matrix A;
        private eigen::vector b;
        public void SetSystem(const eigen::matrix, const eigen::vector)
        public eigen::matrix GetMatrixA()
        public eigen::vector GetVectorB()
        public virtual eigen::vector SysSolve()

    class NonLinSysEqnSolver(SysEqnSolver)
        private double (*F)(eigen::vector y1, eigen::vector y2, double t, double (*f)(double y, double t));
        public void SetSystem(double (*F)(eigen::vector y1, eigen::vector y2, double t, double (*f)(double y, double t)))
        public double (*GetSystemFunction())(eigen::vector y1, eigen::vector y2, double t, double (*f)(double y, double t))
        public virtual eigen::vector SysSolve()

class SolverAlgo
    public virtual eigen::vector Execute(const void* systemData)

    class LinAlgo(SolverAlgo)
        public virtual eigen::vector Execute(const struct LinSystem { eigen::matrix A; eigen::vector b; })

        class GaussianElimination(LinAlgo)
            public eigen::vector Execute(const struct LinSystem { eigen::matrix A; eigen::vector b; })

        class LUDecomposition(LinAlgo)
            public eigen::vector Execute(const struct LinSystem { eigen::matrix A; eigen::vector b; })

    class NonLinAlgo(SolverAlgo)
        public virtual eigen::vector Execute(double (*F)(eigen::vector y1, eigen::vector y2, double t, double (*f)(double y, double t)))

        class NewtonRaphson(NonLinAlgo)
            public eigen::vector Execute(double (*F)(eigen::vector y1, eigen::vector y2, double t, double (*f)(double y, double t)))

        class FixedPointIteration(NonLinAlgo)
            public eigen::vector Execute(double (*F)(eigen::vector y1, eigen::vector y2, double t, double (*f)(double y, double t)))

class ODE_Solver
    private double stepSize;
    private double initialTime;
    private double finalTime;
    private double initialValue;
    private double (*f_rhs)(double y, double t);
    private double RightHandSide(double y, double t) const;
    
    public void SetStepSize(const double h);
    public void SetTimeInterval(const double t0, const double t1);
    public void SetInitialValue(const double y0);
    public void SetRightHandSide(double (*f)(double y, double t));
    
    public double GetFinalTime() const;
    public double GetInitialTime() const;
    public double GetInitialValue() const;
    public double GetStepSize() const;
    
    public virtual void SolveODE(std::ostream &stream) = 0;

class Implicit(ODE_Solver)
    private virtual char DesiredRootFinder;
    public virtual void F_Builder();

    class BwdEuler(Implicit)
        public void F_Builder() override;
        public virtual void SolveODE(std::ostream &stream) override;

    class OtherImplicitMethod(Implicit)
        public void F_Builder() override;
        public virtual void SolveODE(std::ostream &stream) override;

class Explicit(ODE_Solver)
    public virtual void update(double y, double t) = 0;

    class FwdEuler(Explicit)
        public void update(double y, double t) override;
        public virtual void SolveODE(std::ostream &stream) override;

    class RK(Explicit)
        private int order;
        private eigen::matrix coefficients;
        public void update(double y, double t) override;
        public virtual void SolveODE(std::ostream &stream) override;

    class AB(Explicit)
        private int order;
        private eigen::array coefficients;
        public void update(double y, double t) override;
        public virtual void SolveODE(std::ostream &stream) override;